from rdkit import Chem
from rdkit.Chem import rdqueries
import molli as ml
import pandas as pd
import numpy as np
from openbabel import openbabel
from math import sqrt


vdw_dict = {}
vdw_dict["C"] = 1.7
vdw_dict["H"] = 1.2
vdw_dict["O"] = 1.52
vdw_dict["N"] = 1.55
vdw_dict["F"] = 1.47
vdw_dict["S"] = 1.8
vdw_dict["P"] = 1.8
vdw_dict["Cl"] = 1.75
vdw_dict["CL"] = 1.75
vdw_dict["Si"] = 2.1
vdw_dict["SI"] = 2.1
vdw_dict["Br"] = 1.85
vdw_dict["BR"] = 1.85
vdw_dict["I"] = 1.95

symbols_for_rdf = ["C", "N", "S", "O", "F"]


def retrieve_chloride_rdf_descriptors(
    col, apd, increment: float = 1.5, radial_scale: int = 0
):
    """
    Takes collection and json-type atom property descriptors (generated by scraping function built for xTB outputs)

    outputs dataframe for each molecule with conformer-averaged descriptor columns and spherical slices for indices

    These are put into a dictionary with molecule names from the collection as keys.

    Shape of df is 20 rows (two 10 sphere slices for each half of the molecule) with 14 columns of electronic and indicator
    RDFs

    This should be applicable to nitrogen nucleophiles with the exception that one atom list with all atoms should be passed.
    This would give an output with 10 extra rows that could be trimmed or just removed later with variance threshold.

    """
    mol_rdfs = {}  # Going to store dfs in here with name for retrieval for now
    # conf_rdfs = {}
    # print(list(df[3]))
    for mol in col:
        # atom_props = apd[mol.name]
        # print(apd.keys())
        rdf_df = pd.DataFrame(index=["sphere_" + str(i) for i in range(10)])
        rdf_df.name = mol.name
        ### Get reference atoms
        labels = [f.symbol for f in mol.atoms]
        cl_atom = mol.get_atoms_by_symbol(symbol="Cl")[0]
        cl_idx = mol.atoms.index(cl_atom)
        conn = mol.get_connected_atoms(cl_atom)
        if len(conn) != 1:
            raise Exception(
                "More than one group found bonded to cl atom. Check structures"
            )
        elif len(conn) == 1:
            ipso_atom = list(conn)[0]
        else:
            print("foundglitch")
        ipso_idx = mol.atoms.index(ipso_atom)
        rdk_mol = Chem.MolFromMol2Block(mol.to_mol2(), sanitize=False)
        if rdk_mol == None:
            # obabel_ = ml.OpenBabelDriver(name=mol.name,scratch_dir=os.getcwd(),nprocs=1)
            # out = obabel_.convert(mol_text=mol.to_mol2(),src="mol2",dest="smi")
            # print(out)
            obconv = openbabel.OBConversion()
            obconv.SetInAndOutFormats("mol2", "smi")
            obmol = openbabel.OBMol()
            with open("buffer.mol2", "w") as g:
                g.write(mol.to_mol2())
            obconv.ReadFile(obmol, "buffer.mol2")
            obconv.Convert()
            smi = obconv.WriteString(obmol).split()[0]
            if "([N](=O)[O-])" in smi:
                smi = smi.replace("([N](=O)[O-])", "([N+](=O)[O-])")
            # print(smi)
            rdk_mol = Chem.MolFromSmiles(smi)
            # print(rdk_mol)
            # break
        leftref = get_left_reference(rdk_mol, ipso_idx, cl_idx)
        conf_rdfs = {}
        for k, conf in enumerate(mol.conformers):
            df = pd.DataFrame.from_dict(apd[mol.name][k], orient="columns")
            coords = conf.coord
            a, b, c, d = get_molplane(coords, cl_idx, ipso_idx, leftref)
            # print(a, b, c, d)
            orth_out = get_orthogonal_plane(coords, cl_idx, ipso_idx, a, b, c, leftref)
            if orth_out == None:  ### DEBUG
                print(mol.atoms, coords)
                print(f"Mol plane was {a},{b},{c},{d}")
                raise Exception(
                    f"Cannot find orthogonal plane direction for molecule {mol.name}, molecule number {col.molecules.index(mol)} in collection"
                )
            e, f, g, h = orth_out
            h1, h2 = sort_into_halves(mol, conf, e, f, g, h)
            for prop in df.index:
                rdf_ser_1 = get_rdf(
                    coords,
                    cl_idx,
                    h1,
                    df.loc[prop],
                    radial_scaling=radial_scale,
                    inc_size=increment,
                    first_int=1.80,
                )
                rdf_ser_2 = get_rdf(
                    coords,
                    cl_idx,
                    h2,
                    df.loc[prop],
                    radial_scaling=radial_scale,
                    inc_size=increment,
                    first_int=1.80,
                )
                if prop in conf_rdfs.keys():
                    conf_rdfs[prop].append([list(rdf_ser_1), list(rdf_ser_2)])
                else:
                    conf_rdfs[prop] = [[list(rdf_ser_1), list(rdf_ser_2)]]
            rdf_ser_3 = get_atom_ind_rdf(
                mol.atoms, coords, cl_idx, h1, inc_size=increment, first_int=1.80
            )
            rdf_ser_4 = get_atom_ind_rdf(
                mol.atoms, coords, cl_idx, h2, inc_size=increment, first_int=1.80
            )
        for sym, _3, _4 in zip(symbols_for_rdf, rdf_ser_3, rdf_ser_4):
            conf_rdfs[sym + "_rdf"] = [[_3, _4]]
        desc_df = pd.DataFrame()
        for prop, values in conf_rdfs.items():
            array_ = np.array(values)
            avg_array = np.mean(array_, axis=0)
            desc_df[prop] = pd.concat([pd.Series(f) for f in avg_array], axis=0)
        desc_df.index = ["slice_" + str(f + 1) for f in range(20)]
        mol_rdfs[mol.name] = desc_df
    print("all done")
    return mol_rdfs


def retrieve_bromide_rdf_descriptors(
    col, apd, increment: float = 1.5, radial_scale: int = 0
):
    """
    Takes collection and json-type atom property descriptors (generated by scraping function built for xTB outputs)

    outputs dataframe for each molecule with conformer-averaged descriptor columns and spherical slices for indices

    These are put into a dictionary with molecule names from the collection as keys.

    Shape of df is 20 rows (two 10 sphere slices for each half of the molecule) with 14 columns of electronic and indicator
    RDFs

    This should be applicable to nitrogen nucleophiles with the exception that one atom list with all atoms should be passed.
    This would give an output with 10 extra rows that could be trimmed or just removed later with variance threshold.

    """
    mol_rdfs = {}  # Going to store dfs in here with name for retrieval for now
    # conf_rdfs = {}
    # print(list(df[3]))
    for mol in col:
        # atom_props = apd[mol.name]
        # print(apd.keys())
        rdf_df = pd.DataFrame(index=["sphere_" + str(i) for i in range(10)])
        rdf_df.name = mol.name
        ### Get reference atoms
        labels = [f.symbol for f in mol.atoms]
        try:
            br_atom = mol.get_atoms_by_symbol(symbol="Br")[0]
        except:
            raise Exception(
                f"Looks like Br RDF was called on a non-bromide, structure {mol.name}"
            )
        br_idx = mol.atoms.index(br_atom)
        conn = mol.get_connected_atoms(br_atom)
        if len(conn) != 1:
            raise Exception(
                "More than one group found bonded to Br atom. Check structures"
            )
        elif len(conn) == 1:
            ipso_atom = list(conn)[0]
        else:
            print("foundglitch")
        ipso_idx = mol.atoms.index(ipso_atom)
        rdk_mol = Chem.MolFromMol2Block(mol.to_mol2(), sanitize=False)
        if rdk_mol == None:
            # obabel_ = ml.OpenBabelDriver(name=mol.name,scratch_dir=os.getcwd(),nprocs=1)
            # out = obabel_.convert(mol_text=mol.to_mol2(),src="mol2",dest="smi")
            # print(out)
            # print("THISMOLECULEFAILED ", mol.name, col.name)
            obconv = openbabel.OBConversion()
            obconv.SetInAndOutFormats("mol2", "smi")
            obmol = openbabel.OBMol()
            with open("buffer.mol2", "w") as g:
                g.write(mol.to_mol2())
            obconv.ReadFile(obmol, "buffer.mol2")
            obconv.Convert()
            smi = obconv.WriteString(obmol).split()[0]
            if "([N](=O)[O-])" in smi:
                smi = smi.replace("([N](=O)[O-])", "([N+](=O)[O-])")
            # print(smi)
            rdk_mol = Chem.MolFromSmiles(smi)
            # print("AFTER FAILURE, MADE THIS: ", rdk_mol)
            # break
        leftref = get_left_reference(rdk_mol, ipso_idx, br_idx)
        conf_rdfs = {}
        for k, conf in enumerate(mol.conformers):
            df = pd.DataFrame.from_dict(apd[mol.name][k], orient="columns")
            coords = conf.coord
            a, b, c, d = get_molplane(coords, br_idx, ipso_idx, leftref)
            e, f, g, h = get_orthogonal_plane(
                coords, br_idx, ipso_idx, a, b, c, leftref
            )
            h1, h2 = sort_into_halves(mol, conf, e, f, g, h)
            for prop in df.index:
                rdf_ser_1 = get_rdf(
                    coords,
                    br_idx,
                    h1,
                    df.loc[prop],
                    radial_scaling=radial_scale,
                    inc_size=increment,
                    first_int=1.80,
                )
                rdf_ser_2 = get_rdf(
                    coords,
                    br_idx,
                    h2,
                    df.loc[prop],
                    radial_scaling=radial_scale,
                    inc_size=increment,
                    first_int=1.80,
                )
                if prop in conf_rdfs.keys():
                    conf_rdfs[prop].append([list(rdf_ser_1), list(rdf_ser_2)])
                else:
                    conf_rdfs[prop] = [[list(rdf_ser_1), list(rdf_ser_2)]]
            rdf_ser_3 = get_atom_ind_rdf(
                mol.atoms, coords, br_idx, h1, inc_size=increment, first_int=1.80
            )
            rdf_ser_4 = get_atom_ind_rdf(
                mol.atoms, coords, br_idx, h2, inc_size=increment, first_int=1.80
            )
        for sym, _3, _4 in zip(symbols_for_rdf, rdf_ser_3, rdf_ser_4):
            conf_rdfs[sym + "_rdf"] = [[_3, _4]]
        desc_df = pd.DataFrame()
        for prop, values in conf_rdfs.items():
            array_ = np.array(values)
            avg_array = np.mean(array_, axis=0)
            desc_df[prop] = pd.concat([pd.Series(f) for f in avg_array], axis=0)
        desc_df.index = ["slice_" + str(f + 1) for f in range(20)]
        mol_rdfs[mol.name] = desc_df
    # print("all done")
    return mol_rdfs


def get_amine_ref_n(mol: ml.Molecule):
    """
    Returns the reference atom index for the nitrogen with an H (assumes only one)
    """
    nit_atm = False
    for atm in mol.get_atoms_by_symbol(symbol="N"):
        nbrs = mol.get_connected_atoms(atm)
        for nbr in nbrs:
            # print(nbr.symbol)
            if nbr.symbol == "H":
                nit_atm = atm
                return nit_atm


def retrieve_amine_rdf_descriptors(
    col, apd, increment: float = 1.1, radial_scale: int = 0
):
    """
    Takes collection and json-type atom property descriptors (generated by scraping function built for xTB outputs)

    outputs dataframe for each molecule with conformer-averaged descriptor columns and spherical slices for indices

    These are put into a dictionary with molecule names from the collection as keys.

    Shape of df is 20 rows (two 10 sphere slices for each half of the molecule) with 14 columns of electronic and indicator
    RDFs

    This should be applicable to nitrogen nucleophiles with the exception that one atom list with all atoms should be passed.
    This would give an output with 10 extra rows that could be trimmed or just removed later with variance threshold.

    """
    mol_rdfs = {}  # Going to store dfs in here with name for retrieval for now
    for mol in col:
        # atom_props = apd[mol.name]
        # print(apd.keys())
        rdf_df = pd.DataFrame(index=["sphere_" + str(i) for i in range(10)])
        rdf_df.name = mol.name
        ### Get reference atoms
        # labels = [f.symbol for f in mol.atoms]
        # br_atom = mol.get_atoms_by_symbol(symbol='Br')[0]
        n_atom = get_amine_ref_n(mol)
        n_idx = mol.atoms.index(n_atom)
        conn = mol.get_connected_atoms(n_atom)
        if len(conn) == 1:
            raise Exception(
                "More than one group found bonded to Br atom. Check structures"
            )
        conf_rdfs = {}
        a_idx_l = [mol.atoms.index(f) for f in mol.atoms]
        for k, conf in enumerate(mol.conformers):
            # print("DEBUG", k, mol.name)
            df = pd.DataFrame.from_dict(apd[mol.name][k], orient="columns")
            coords = conf.coord
            # a,b,c,d = get_molplane(coords,n_idx,ipso_idx,leftref)
            # e,f,g,h = get_orthogonal_plane(coords,n_idx,ipso_idx,a,b,c,leftref)
            # h1,h2 = sort_into_halves(mol,conf,e,f,g,h)
            for prop in df.index:
                rdf_ser_1 = get_rdf(
                    coords,
                    n_idx,
                    a_idx_l,
                    df.loc[prop],
                    radial_scaling=radial_scale,
                    inc_size=increment,
                    first_int=1.20,
                )
                if prop in conf_rdfs.keys():
                    conf_rdfs[prop].append([list(rdf_ser_1)])
                else:
                    conf_rdfs[prop] = [[list(rdf_ser_1)]]
            rdf_ser_3 = get_atom_ind_rdf(
                mol.atoms, coords, n_idx, a_idx_l, inc_size=increment, first_int=1.20
            )
        for sym, _3 in zip(symbols_for_rdf, rdf_ser_3):
            conf_rdfs[sym + "_rdf"] = [[_3]]
        desc_df = pd.DataFrame()
        for prop, values in conf_rdfs.items():
            array_ = np.array(values)
            avg_array = np.mean(array_, axis=0)
            desc_df[prop] = pd.concat([pd.Series(f) for f in avg_array], axis=0)
        desc_df.index = ["slice_" + str(f + 1) for f in range(10)]
        mol_rdfs[mol.name] = desc_df
    # print("all done")
    return mol_rdfs


def get_rdf(
    coords: ml.dtypes.CartesianGeometry,
    reference_idx: int,
    atom_list,
    all_atoms_property_list: list,
    inc_size=0.90,
    first_int: float = 1.80,
    radial_scaling: int or None = 0,
):
    """
    Takes coordinates for molecule, reference atom index, list of atom indices to compute for, and property list ordered by atom idx

    radial_scaling is an exponent for 1/(r^n) scaling the descriptors - whatever they may be

    """
    al = []
    bl = []
    cl = []
    dl = []
    el = []
    fl = []
    gl = []
    hl = []
    il = []
    jl = []
    central_atom = coords[reference_idx]
    # print(atom_list)
    for x in atom_list:
        point = coords[x]
        # print(point)
        # print(central_atom)
        dist = sqrt(
            (
                (float(central_atom[0]) - float(point[0])) ** 2
                + (float(central_atom[1]) - float(point[1])) ** 2
                + (float(central_atom[2]) - float(point[2])) ** 2
            )
        )
        # atom = ''.join([i for i in x if not i.isdigit()])
        property = list(all_atoms_property_list)[x]
        try:
            property_ = float(property)
        except:
            property_ = 4.1888 * vdw_dict[property] ** 3
        const = first_int
        if radial_scaling == 0 or radial_scaling == None:
            pass
        elif type(radial_scaling) is int and radial_scaling != 0:
            property_ = property_ / (dist**radial_scaling)
        else:
            raise ValueError("radial scaling exponent should be an integer or None")
        if dist <= const + inc_size:
            al.append(property_)
        elif dist > const + inc_size and dist <= const + inc_size * 2:
            bl.append(property_)
        elif dist > const + inc_size * 2 and dist <= const + inc_size * 3:
            cl.append(property_)
        elif dist > const + inc_size * 3 and dist <= const + inc_size * 4:
            dl.append(property_)
        elif dist > const + inc_size * 4 and dist <= const + inc_size * 5:
            el.append(property_)
        elif dist > const + inc_size * 5 and dist <= const + inc_size * 6:
            fl.append(property_)
        elif dist > const + inc_size * 6 and dist <= const + inc_size * 7:
            gl.append(property_)
        elif dist > const + inc_size * 7 and dist <= const + inc_size * 8:
            hl.append(property_)
        elif dist > const + inc_size * 8 and dist <= const + inc_size * 9:
            il.append(property_)
        elif dist > const + inc_size * 9:
            jl.append(property_)
    series_ = pd.Series(
        [
            sum(al),
            sum(bl),
            sum(cl),
            sum(dl),
            sum(el),
            sum(fl),
            sum(gl),
            sum(hl),
            sum(il),
            sum(jl),
        ],
        index=["sphere_" + str(f + 1) for f in range(10)],
    )
    """
    print al
    print bl
    print cl
    print dl
    print el
    print fl
    print gl
    print hl
    print il
    print jl
    """
    return series_


def get_atom_ind_rdf(
    atoms: list[ml.dtypes.Atom],
    coords: ml.dtypes.CartesianGeometry,
    reference_idx: int,
    atom_list,
    first_int: float = 1.80,
    inc_size=0.90,
):
    """
    Takes atoms and returns simple binary indicator for presence of specific atom types. These are not distance-weighted.
    """
    atomtypes = ["C", "N", "S", "O", "F"]
    outlist = []
    for symb in atomtypes:
        al = []
        bl = []
        cl = []
        dl = []
        el = []
        fl = []
        gl = []
        hl = []
        il = []
        jl = []
        central_atom = coords[reference_idx]
        # print(atom_list)
        for x in atom_list:
            point = coords[x]
            symbol = atoms[x].symbol
            if symbol != symb:
                continue
            dist = sqrt(
                (
                    (float(central_atom[0]) - float(point[0])) ** 2
                    + (float(central_atom[1]) - float(point[1])) ** 2
                    + (float(central_atom[2]) - float(point[2])) ** 2
                )
            )
            const = first_int
            if dist <= const + inc_size:
                al.append(1)
            elif dist > const + inc_size and dist <= const + inc_size * 2:
                bl.append(1)
            elif dist > const + inc_size * 2 and dist <= const + inc_size * 3:
                cl.append(1)
            elif dist > const + inc_size * 3 and dist <= const + inc_size * 4:
                dl.append(1)
            elif dist > const + inc_size * 4 and dist <= const + inc_size * 5:
                el.append(1)
            elif dist > const + inc_size * 5 and dist <= const + inc_size * 6:
                fl.append(1)
            elif dist > const + inc_size * 6 and dist <= const + inc_size * 7:
                gl.append(1)
            elif dist > const + inc_size * 7 and dist <= const + inc_size * 8:
                hl.append(1)
            elif dist > const + inc_size * 8 and dist <= const + inc_size * 9:
                il.append(1)
            elif dist > const + inc_size * 9:
                jl.append(1)
        series_ = [
            sum(al),
            sum(bl),
            sum(cl),
            sum(dl),
            sum(el),
            sum(fl),
            sum(gl),
            sum(hl),
            sum(il),
            sum(jl),
        ]
        outlist.append(series_)
    # output = np.array(outlist).T.tolist()
    output = outlist
    return output


def get_molplane(coords: np.array, ref_1, ref_2, ref_3):
    """
    Makes plane of molecule. Bromide for bromides, nitrogen for amines as ref atom.

    Br, ipso, leftref
    """
    # Setting up reference points
    p1 = np.array(coords[ref_1])
    p2 = np.array(coords[ref_2])
    p3 = np.array(coords[ref_3])
    # Setting up reference vectors - Br-C bond, leftref - br
    v1 = p2 - p1
    v2 = p3 - p1
    # Calculating plane's vector to get direction
    cp = np.cross(v1, v2)
    a, b, c = cp
    # Calculating position for plane
    d = np.dot(cp, p1)
    return a, b, c, d


# def get_orthogonal_plane(coords: np.array, ref_1, ref_2, a, b, c, leftref):
#     """
#     Retrieve orthogonal plane to molecule, but containing reactive atom
#     ref1 is the reactive atom (br or n)
#     ref2 is the atom attached to it (for making a direction towards the molecule)
#     """
#     p1 = np.array(coords[ref_1])
#     p2 = np.array(coords[ref_2])
#     # This is important - we use a specific reference atom here.
#     p3 = np.array(coords[leftref])  # for "positive" direction left/right
#     v1 = p2 - p1  # Vector along Br-ipsoC bond
#     # Molplane vector
#     v2 = np.array([a, b, c])
#     # Crossing molplane direction with the Br-C bond to get orthogonal plane direction
#     cp = np.cross(v1, v2)
#     e, f, g = cp
#     vc = np.array([e, f, g])  # direction of orthogonal plane (i.e. "left" or "right")
#     # To define the specific orthogonal plane, need to know leftref directions
#     if np.dot(vc, p3) > 0:  # query leftref vector vs orthogonal plane
#         h = np.dot(vc, p1)
#         return e, f, g, h
#     elif np.dot(vc, p3) < 0:  # wrong direction; cross the other way
#         cp = np.cross(v2, v1)
#         e, f, g = cp
#         vc = np.array([e, f, g])
#         h = np.dot(vc, p1)
#         return e, f, g, h
#     else:
#         raise Exception("Failed to calculate molecular planes")


def get_orthogonal_plane(coords: np.array, ref_1, ref_2, a, b, c, leftref):
    """
    DEV VERSION - MAKING COMPATIBLE WITH CL CALCULATIONS
    Retrieve orthogonal plane to molecule, but containing reactive atom
    ref1 is the reactive atom (br or n)
    ref2 is the atom attached to it (for making a direction towards the molecule)
    """
    p1 = np.array(coords[ref_1])  # Halogen
    p2 = np.array(coords[ref_2])  # Ipso atom
    p4 = np.array(coords[leftref])  # for "positive" direction left/right
    v1 = p2 - p1  # ipso to halogen
    v2 = np.array([a, b, c])  # vector for molecular plane
    cp = np.cross(v1, v2)
    # print(cp)
    e, f, g = cp
    vc = np.array([e, f, g])  # vector for orthogonal plane
    # print("norm vect", vc)
    # print("p1", p1)
    # print("p4", p4)
    # print(np.dot(vc, p4))
    # print(leftref)
    # print(ref_1)

    if np.dot(vc, p4) > 0:
        h = np.dot(vc, p1)
        return e, f, g, h
    elif np.dot(vc, p4) < 0:
        cp = np.cross(v2, v1)
        e, f, g = cp
        vc = np.array([e, f, g])
        h = np.dot(vc, p1)
        return e, f, g, h
    else:
        print(f"Not finding direction for molecule; dot output is {np.dot(vc,p4)}")
        print(f"Cl is at {p1}, ipso is at {p2}, left reference is at {p4}")
        print(f"Plane is {vc}, molecular plane is {v2}, and halogen bond is {v1}")
        return None


def sort_into_halves(mol: ml.Molecule, conf: ml.dtypes.CartesianGeometry, e, f, g, h):
    """
    This function takes in the atom list and spits out a list of lists with atoms sorted
    into octants. This is done with the three orthonormal planes defined by get_orthogonal_planes
    """
    coords: np.array = conf.coord
    oct1 = []
    oct2 = []
    cp = np.array([e, f, g])
    # cp_ = [np.float64(e),np.float64(f),np.float64(g)]
    for i, pos in enumerate(coords):
        direction_ = (np.tensordot(pos, cp, axes=1) - h) / abs(
            sqrt(e**2 + f**2 + g**2)
        )
        if direction_ > 0.15:
            oct1.append(i)
        elif direction_ < -0.15:
            oct2.append(i)
    return [oct1, oct2]


def get_left_reference(mol: Chem.rdchem.Mol, ipso_idx, br_idx):
    """
    return leftref
    """
    ipso_reference = mol.GetAtomWithIdx(ipso_idx)
    br_ref = mol.GetAtomWithIdx(br_idx)
    ortho_het, meta_het = get_ortho_meta_symbols(mol, ipso_idx)
    # print(ortho_het,meta_het)
    if len(ortho_het) == 0:  # no ortho heteroatoms
        less_sub = get_less_substituted_ortho(mol, ipso_idx)
        # print(less_sub,'less_sub_ortho')
        if less_sub == None:  # ortho both the same
            if len(meta_het) == 0:  # no meta het, so using substitution
                less_meta_sub = get_less_substituted_meta(mol, ipso_idx)
                # print(less_meta_sub,'less_meta_sub')
                if less_meta_sub == None:
                    nbrs = [
                        f for f in ipso_reference.GetNeighbors() if f.GetIdx() != br_idx
                    ]
                    # print([f.GetIdx() for f in nbrs])
                    leftref = nbrs[0].GetIdx()  # arbitrary; symmetric
                elif (
                    less_meta_sub != None
                ):  # using less substituted meta atom for left reference
                    leftref = less_meta_sub
            elif len(meta_het) == 1:  # list of tuples (symbol, idx, atomic num)
                leftref = meta_het[0][1]
            elif len(meta_het) == 2:
                if (
                    meta_het[0][2] > meta_het[1][2]
                ):  # atomic number of first greater than atomic number of second
                    leftref = meta_het[0][1]
                elif meta_het[0][2] < meta_het[1][2]:
                    leftref = meta_het[1][1]
                elif meta_het[0][2] == meta_het[1][2]:
                    leftref = meta_het[0][1]  # arbitrary if they are the same
        elif less_sub != None:
            leftref = less_sub  # If one side is less substituted AND no heteroatoms were found
    elif len(ortho_het) == 1:
        leftref = ortho_het[0][1]  # heteroatom in ortho defines
    elif len(ortho_het) == 2:  # both ortho are het
        if (
            ortho_het[0][2] > ortho_het[1][2]
        ):  # atomic number of first greater than atomic number of second
            leftref = ortho_het[0][1]
        elif ortho_het[0][2] < ortho_het[1][2]:
            leftref = ortho_het[1][1]
        elif ortho_het[0][2] == ortho_het[1][2]:
            leftref = ortho_het[0][1]  # arbitrary if they are the same
    else:
        print("Error! Could not find bromide left reference after all conditions")
    return leftref


def get_ortho_meta_symbols(mol: Chem.rdchem.Mol, aryl_ref):
    """
    Finds out if and what heteroatoms are in the ortho-positions of aniline-type amines
    Returns list of ortho heteroatoms and then meta heteroatoms
    Form is: tuple (symbol,index,atomicnumber)
    Third value can be used to sort these by importance

    This should work for bromides!!!
    Uses ipso carbon as reference atom.
    """
    pt = Chem.GetPeriodicTable()
    # if is_aniline(mol,refn)==False:
    #     print('error! trying to use aniline func on non aniline!')
    #     return None
    ar_atm = get_aromatic_atoms(mol)  # all aryl atoms
    # print(ar_atm,aryl_ref)
    if aryl_ref not in ar_atm:
        print("weird")
        return None  # This is weird; error here if this happens
    het_ar_atm = []  # list of tuples describing heteroarene heteroatoms, empty if none
    for atm in ar_atm:  # Loop over aromatic atoms to find heteroaromatic atoms
        symb = mol.GetAtomWithIdx(atm).GetSymbol()
        if symb != "C":
            het_ar_atm.append(tuple([symb, atm]))
    refatom = mol.GetAtomWithIdx(aryl_ref)
    nbrs = refatom.GetNeighbors()
    ortho_het = []
    meta_het = []
    for nbr in nbrs:  # This looks at ortho atoms
        test_value = tuple([nbr.GetSymbol(), nbr.GetIdx()])
        if test_value in het_ar_atm:
            ortho_het.append(
                tuple([f for f in test_value] + [pt.GetAtomicNumber(test_value[0])])
            )
        nbr2 = [f for f in nbr.GetNeighbors() if f not in nbrs]
        for nbrr in nbr2:  # This looks at one further atom out from ortho
            test_val_2 = tuple([nbrr.GetSymbol(), nbrr.GetIdx()])
            if test_val_2 in het_ar_atm:
                meta_het.append(
                    tuple([f for f in test_val_2] + [pt.GetAtomicNumber(test_val_2[0])])
                )
    # print(ortho_het,meta_het)
    return ortho_het, meta_het


def get_aromatic_atoms(mol: Chem.rdchem.Mol):
    """
    Self explanatory: retrieves atom indices for aromatic atoms in mol

    NOTE: for multi-nuclear arenes (i.e. naphthalene, etc), this will give ALL aromatic atoms
    Therefore, the primary aromatic ring atoms will be included in this, but the list will not exclusively contain them.

    Some heterocycles (particularly pi-rich) are not parsed properly - this is an RDKit problem. It will be solved eventually.
    """

    q = rdqueries.IsAromaticQueryAtom()
    return [x.GetIdx() for x in mol.GetAtomsMatchingQuery(q)]


def get_less_substituted_ortho(mol: Chem.rdchem.Mol, atomidx):
    """
    Basic idea: retrieve aromatic atom in primary ring which is ortho to C-Br

    This is used to define left/right halves of molecule for RDF

    """

    atomref = mol.GetAtomWithIdx(atomidx)
    nbrs = atomref.GetNeighbors()
    nbrs_ = [
        f
        for f in nbrs
        if f.GetSymbol() != "H"
        and f.GetSymbol() != "Br"
        and f.GetSymbol() != "N"
        and f.GetSymbol() != "Cl"
    ]  # No H, Br, Cl, or N
    nbrlist = [[k.GetSymbol() for k in f.GetNeighbors()] for f in nbrs_]
    cntlist = [f.count("H") for f in nbrlist]
    if cntlist.count(cntlist[0]) == len(cntlist):
        return None  # This means H count is same
    min_v = min(cntlist)
    min_indx = cntlist.index(min_v)
    lesssub = nbrs_[min_indx].GetIdx()
    return lesssub


def get_less_substituted_meta(mol: Chem.rdchem.Mol, ipsoidx):
    """
    Basic idea: retrieve aromatic atom in primary ring meta to C-Br which is less substituted

    This is used to define left vs right halves

    """

    atomref = mol.GetAtomWithIdx(ipsoidx)
    nbrs = atomref.GetNeighbors()
    nbrs_ = [f for f in nbrs if f.GetSymbol() != "H"]
    atomrings = mol.GetRingInfo().AtomRings()
    for ring in atomrings:
        if ipsoidx in ring:
            mainring = ring
    meta_ = [
        [
            k
            for k in f.GetNeighbors()
            if k.GetIdx() not in [p.GetIdx() for p in nbrs_]
            and k.GetSymbol != "H"
            and k.GetIdx() in mainring
            and k.GetIdx() != ipsoidx
        ]
        for f in nbrs_
    ]
    meta_ = [p for p in meta_ if len(p) != 0]
    # for f in meta_:
    #     print(f,'test')
    meta_type_list = [
        [k.GetSymbol() for k in f[0].GetNeighbors()] for f in meta_
    ]  # List with one item; need index in nested inner list
    cntlist = [f.count("H") for f in meta_type_list]
    if cntlist.count(cntlist[0]) == len(cntlist):
        return None  # This means H count is same
    min_v = min(cntlist)
    min_indx = cntlist.index(min_v)
    lesssub = meta_[min_indx][0].GetIdx()
    # print(lesssub)
    return lesssub

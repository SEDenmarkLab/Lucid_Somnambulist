# This workflow adds structures to the feature database (without requiring experimental data).
# This may be useful for analyzing component space or performing unsupervised learning tasks.
# This workflow also can be used by predict to generate features for new structures.

from sys import argv
import molli as ml
import argparse
from pathlib import Path
from somn.build import parsing

# from somn.workflows import STRUC_
from somn.calculate.geom import PropheticInput
import warnings
from somn.util.project import Project

# temp_work = r"C:\Users\rineharn\workspace/"
# temp_work = r"/mnt/c/Users/rineharn/workspace/linux/"

#### Use example
# python add.py smi 'CC(=O)N1CCN(CC1)C2=CC=C(C=C2)OC[C@@H]3CO[C@@](O3)(CN4C=CN=C4)C5=C(C=C(C=C5)Cl)Cl' el
####


if __name__ == "__main__":
    ### Basic checks on the input - start with the more difficult cdxml input, then go to smiles later
    ### Use molli for cdxml parse - it is better than openbabel. Use openbabel for smiles parsing and adding hydrogens (to both)
    project = Project()
    assert len(argv) > 1
    parser = argparse.ArgumentParser(
        usage="Specify format (smi or cdxml), then a smiles string/file with smiles or cdxml file, and finally indicate 'el' or 'nuc' for electrophile or nucleophile. Optionally, serialize output structures with '-ser' - must pass some input as an argument after, standard use is 'y'"
    )
    parser.add_argument(
        "fmt",
        nargs=2,
        help="Format for the input - cdxml or smi, followed by file or smiles string",
    )
    parser.add_argument(
        "r", help="The type of input - nucleophile (nuc) or electrophile (el)"
    )
    parser.add_argument(
        "-ser",
        help="Optional serialize argument, pass -ser and the path to save to",
    )
    args = parser.parse_args()
    ###                     Check serialization and instantiate parser              ###
    if (
        args.ser
    ):  # Serialization during parsing to check for errors - this is important for users to troubleshoot
        # assert Path(args.ser[1]).exists()
        parse = parsing.InputParser(
            serialize=True, path_to_write=str(project.structures)
        )
    else:
        parse = parsing.InputParser(serialize=False)

    ###             Checking inputs and generating initial 3D geometries.            ###

    if args.fmt[0] == "smi":
        # raise Exception(
        #     "SMILES parsing not yet supported; please use fpath option for CDXML"
        # )
        if Path(args.fmt[1]).exists():
            raise Exception(
                "Looks like a file path was passed as a SMILES - check inputs. If multiple smiles are being input, use 'multsmi' for format"
            )
        assert args.r in ["nuc", "el"]
        try:
            collection, smiles_d = parse.get_mol_from_smiles(args.fmt[1])
        except:
            raise Warning(
                "Something went wrong with openbabel smiles parsing - check input/output"
            )
        prep, err = parse.preopt_geom(collection)
    elif args.fmt[0] == "multsmi":
        print("got to multsmi")
        if Path(args.fmt[1]).suffix == ".smi":
            multismi_inp = parse.scrape_biovia_smi_file(args.fmt[1])
            collection, smiles_d = parse.get_mol_from_smiles(
                multismi_inp, recursive_mode=True
            )
        elif Path(args.fmg[1]).suffix == ".csv":
            collection, smiles_d, roles = parse.scrape_smiles_csv(args.fmt[1])
            prep, err = parse.prep_collection(collection, update=20)
        else:
            raise Exception(
                "Multiple molecule input only accepts unlabelled .smi file (can be generated by biovia), where all molecules must be the same role OR\n \
                a .csv file with a smiles string, role (nuc or el), and optional name as each row."
            )
    elif args.fmt[0] == "cdxml":
        try:
            p = Path(args.fmt[1])
            assert p.exists()
        except:
            raise Exception(
                "Please pass a valid path for a cdxml file - parsing failed"
            )
        collection = parse.get_mol_from_graph(args.fmt[1])
        smiles_d = parse.get_smi_from_mols(collection)
        prep, err = parse.prep_collection(collection)
    else:
        raise Exception(
            "Please pass cdxml or smiles as input. See help for instructions."
        )

    ###             Building pipeline object for getting molecular geometries           ###

    collection.to_zip(parse.path_to_write + "/input_struc_preopt_col.zip")
    import json

    assert not Path(
        str(project.structures) + "/newmol_smi_buffer.json"
    ).exists()  # Make sure we won't overwrite something
    with open(f"{project.structures}/newmol_smi_buffer.json", "w") as k:
        json.dump(smiles_d, k)

    smi_list = [smiles_d[n.name] for n in collection.molecules]

    if args.fmt[0] == "smi":
        input_packet = PropheticInput.from_col(collection, smi_list, [args.r])
        # print(input_packet.struc)

    elif args.fmt[0] == "multismi":
        input_packet = PropheticInput.from_col(collection, smi_list, roles)
        # print(input_packet.struc)
    elif args.fmt[0] == "cdxml":
        input_packet = PropheticInput.from_col(
            collection, smi_list, [args.r for f in collection.molecules]
        )
        # print(input_packet.struc)
    else:
        raise Exception(
            "There was an error attributing reactant roles for input structures"
        )
    ###                         Running conformer pipeline                               ###
    input_packet.conformer_pipeline()
    atomprops, ap_errors = input_packet.atomprop_pipeline()
    if len(ap_errors) > 0:
        warnings.warn(
            f"Looks like {len(ap_errors)} molecules failed at the atomproperty calculation step - this singlepoint calc usually fails because \
            the input structure is not valid. Check that backed up structure in the working directory {project.structures}"
        )
    with open(f"{project.structures}/newmol_ap_buffer.json", "w") as k:
        json.dump(atomprops, k)

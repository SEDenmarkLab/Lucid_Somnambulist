# This workflow adds structures to the feature database (without requiring experimental data).
# This may be useful for analyzing component space or performing unsupervised learning tasks.
# This workflow also can be used by predict to generate features for new structures.
import os

os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
from sys import argv
import molli as ml
import argparse
from pathlib import Path
from somn.build import parsing

from somn.calculate.substrate import PropheticInput
import warnings
from somn.util.project import Project


def add_workflow(
    project: Project,
    prediction_experiment: str,
    parser_args=[],
):
    ### Basic checks on the input - start with the more difficult cdxml input, then go to smiles later
    ### Use molli for cdxml parse - it is better than openbabel. Use openbabel for smiles parsing and adding hydrogens (to both)

    """
    First argument is format

    Second argument is the input (based on format)

    Third argument is the role (nuc or el)

    Fourth argument is optional, -ser and any value after this will serialize. This isn't quite implemented as of early 5/2023. It defaults to yes.

    """

    assert (len(parser_args) > 1) or (len(argv) > 1)
    parser = argparse.ArgumentParser(
        usage="Specify format (smi or cdxml), then a smiles string/file with smiles or cdxml file, and finally indicate 'el' or 'nuc' for electrophile or nucleophile. Optionally, serialize output structures with '-ser' - must pass some input as an argument after, standard use is 'y'"
    )
    parser.add_argument(
        "fmt",
        nargs=2,
        help="Format for the input - cdxml or smi, followed by file or smiles string",
    )
    parser.add_argument(
        "r", help="The type of input - nucleophile (nuc) or electrophile (el)"
    )
    parser.add_argument(
        "-ser",
        help="Optional serialize argument, pass -ser t",
    )
    if parser_args == []:
        args = parser.parse_args(argv[1:])
    else:
        args = parser.parse_args(parser_args)
    ###                     Check serialization and instantiate parser              ###
    if (
        args.ser
    ):  # Serialization during parsing to check for errors - this is important for users to troubleshoot
        parse = parsing.InputParser(
            serialize=True,
            path_to_write=f"{project.structures}/{prediction_experiment}",
        )
        project.save(identifier=args.ser)  # Testing
    else:
        parse = parsing.InputParser(serialize=False)
        project.save()

    ###             Checking inputs and generating initial 3D geometries.            ###

    if args.fmt[0] == "smi":
        if Path(args.fmt[1]).exists():
            raise Exception(
                "Looks like a file path was passed as a SMILES - check inputs. If multiple smiles are being input, use 'multsmi' for format"
            )
        assert args.r in ["nuc", "el"]
        try:
            pre, smiles_d = parse.get_mol_from_smiles(args.fmt[1])
        except:
            raise Exception(
                "Something went wrong with openbabel smiles parsing - check input/output"
            )
        collection, err = parse.preopt_geom(pre)
    elif args.fmt[0] == "multsmi":
        if Path(args.fmt[1]).suffix == ".smi":
            multismi_inp = parse.scrape_biovia_smi_file(args.fmt[1])
            collection, smiles_d = parse.get_mol_from_smiles(
                multismi_inp, recursive_mode=True
            )
        elif Path(args.fmt[1]).suffix == ".csv":
            pre, smiles_d, roles, indicies = parse.scrape_requests_csv(args.fmt[1])
            collection, err = parse.prep_collection(pre, update=20, has_hs=True)
        else:
            raise Exception(
                "Multiple molecule input only accepts unlabelled .smi file (can be generated by biovia), where all molecules must be the same role OR\n \
                a .csv file with a smiles string, role (nuc or el), and optional name as each row."
            )
    elif args.fmt[0] == "cdxml":  ## Not tested yet - low priority
        try:
            p = Path(args.fmt[1])
            assert p.exists()
        except:
            raise Exception(
                "Please pass a valid path for a cdxml file - parsing failed"
            )
        pre = parse.get_mol_from_graph(args.fmt[1])
        collection, err = parse.prep_collection(
            pre, has_hs=False
        )  # Hs not explicitly specified in cdxml, and scrubbed during parsing above.
        smiles_d = parse.get_smi_from_mols(collection)
    elif args.fmt[0] == "mol2":
        try:
            p = Path(args.fmt[1])
            assert p.exists()
        except:
            raise Exception(
                "Tried inputting a mol2, but did not specify a valid file path. Check input string."
            )
        mol = ml.Molecule.from_file(args.fmt[1])
        mol.name = p.stem.strip("/").strip(r"\\")  # strip slashes just in case
        assert isinstance(mol, ml.Molecule)
        pre = ml.Collection(name="mol2input", molecules=[mol])
        smiles_d = parse.get_smi_from_mols(pre)
        collection, err = parse.prep_collection(pre, has_hs=True)
    else:
        raise Exception(
            "Please pass cdxml or smiles as input. See help for instructions."
        )

    ###             Building pipeline object for getting molecular geometries           ###

    collection.to_zip(parse.path_to_write + "/input_struc_preopt_col.zip")
    import json

    try:
        assert not Path(
            str(parse.path_to_write) + "/newmol_smi_buffer.json"
        ).exists()  # Make sure we won't overwrite something
    except:
        raise Exception(
            f"{parse.path_to_write} was passed as the path to write for molecule input, but it exists. To avoid overwriting, workflow has been aborted."
        )
    with open(f"{parse.path_to_write}/newmol_smi_buffer.json", "w") as k:
        json.dump(smiles_d, k)

    smi_list = [smiles_d[n.name] for n in collection.molecules]

    if args.fmt[0] == "smi":  # Single structure
        input_packet = PropheticInput.from_col(
            collection, smi_list, [args.r], parser=parse
        )

    elif args.fmt[0] == "multsmi":
        input_packet = PropheticInput.from_col(
            collection, smi_list, roles, parser=parse
        )
    elif args.fmt[0] == "cdxml":
        input_packet = PropheticInput.from_col(
            collection, smi_list, [args.r for f in collection.molecules], parser=parse
        )
    elif args.fmt[0] == "mol2":  # Single structure
        input_packet = PropheticInput.from_col(
            collection, smi_list, [args.r], parser=parse
        )
    else:
        raise Exception(
            "There was an error attributing reactant roles for input structures"
        )
    ###                         Running conformer pipeline                               ###
    print("STARTING CONFORMER GENERATION AND SCREENING")
    input_packet.conformer_pipeline()
    print("STARTING ATOM PROPERTY CALCULATION")
    atomprops, ap_errors = input_packet.atomprop_pipeline()
    if len(ap_errors) > 0:
        warnings.warn(
            f"Looks like {len(ap_errors)} molecules failed at the atomproperty calculation step - this singlepoint calc usually fails because \
            the input structure is not valid. Check that backed up structure in the working directory {parse.path_to_write}"
        )
    with open(f"{parse.path_to_write}/newmol_ap_buffer.json", "w") as k:
        json.dump(atomprops, k)

    if len(ap_errors) != 0:
        print(f"ERRORS DURING CALCULATIONS: \n{ap_errors}")
    input_packet.sort_and_write_outputs(substrate_indicies=indicies)


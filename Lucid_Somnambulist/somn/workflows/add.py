# This workflow adds structures to the feature database (without requiring experimental data).
# This may be useful for analyzing component space or performing unsupervised learning tasks.
# This workflow also can be used by predict to generate features for new structures.

from sys import argv
import molli as ml
import argparse
from pathlib import Path
from somn.build import parsing
from somn.workflows import STRUC_
from somn.calculate.geom import PropheticInput
import warnings

# temp_work = r"C:\Users\rineharn\workspace/"
# temp_work = r"/mnt/c/Users/rineharn/workspace/linux/"

#### Use example
# python add.py smi 'CC(=O)N1CCN(CC1)C2=CC=C(C=C2)OC[C@@H]3CO[C@@](O3)(CN4C=CN=C4)C5=C(C=C(C=C5)Cl)Cl' el
####


def add_workflow():
    ### Basic checks on the input - start with the more difficult cdxml input, then go to smiles later
    ### Use molli for cdxml parse - it is better than openbabel. Use openbabel for smiles parsing and adding hydrogens (to both)
    """
    First argument is format

    Second argument is the input (based on format)

    Third argument is the role (nuc or el)

    Fourth argument is optional, -ser and any value after this will serialize. This isn't quite implemented as of early 5/2023. It defaults to yes.

    """

    assert len(argv) > 1
    parser = argparse.ArgumentParser(
        usage="Specify format (smi or cdxml), then a smiles string/file with smiles or cdxml file, and finally indicate 'el' or 'nuc' for electrophile or nucleophile. Optionally, serialize output structures with '-ser' - must pass some input as an argument after, standard use is 'y'"
    )
    parser.add_argument(
        "fmt",
        nargs=2,
        help="Format for the input - cdxml or smi, followed by file or smiles string",
    )
    parser.add_argument(
        "r", help="The type of input - nucleophile (nuc) or electrophile (el)"
    )
    parser.add_argument(
        "-ser",
        help="Optional serialize argument, pass -ser and the path to save to",
    )
    args = parser.parse_args()
    ###                     Check serialization and instantiate parser              ###
    if (
        args.ser
    ):  # Serialization during parsing to check for errors - this is important for users to troubleshoot
        # assert Path(args.ser[1]).exists()
        parse = parsing.InputParser(serialize=True, path_to_write=STRUC_)
    else:
        parse = parsing.InputParser(serialize=False)

    ###             Checking inputs and generating initial 3D geometries.            ###

    if args.fmt[0] == "smi":
        # raise Exception(
        #     "SMILES parsing not yet supported; please use fpath option for CDXML"
        # )
        if Path(args.fmt[1]).exists():
            raise Exception(
                "Looks like a file path was passed as a SMILES - check inputs. If multiple smiles are being input, use 'multsmi' for format"
            )
        assert args.r in ["nuc", "el"]
        try:
            pre, smiles_d = parse.get_mol_from_smiles(args.fmt[1])
        except:
            raise Warning(
                "Something went wrong with openbabel smiles parsing - check input/output"
            )
        collection, err = parse.preopt_geom(pre)
    elif args.fmt[0] == "multsmi":
        print("got to multsmi")
        if Path(args.fmt[1]).suffix == ".smi":
            multismi_inp = parse.scrape_biovia_smi_file(args.fmt[1])
            collection, smiles_d = parse.get_mol_from_smiles(
                multismi_inp, recursive_mode=True
            )
        elif Path(args.fmg[1]).suffix == ".csv":
            pre, smiles_d, roles = parse.scrape_smiles_csv(args.fmt[1])
            collection, err = parse.prep_collection(pre, update=20)
        else:
            raise Exception(
                "Multiple molecule input only accepts unlabelled .smi file (can be generated by biovia), where all molecules must be the same role OR\n \
                a .csv file with a smiles string, role (nuc or el), and optional name as each row."
            )
    elif args.fmt[0] == "cdxml":  ## Not tested yet - low priority
        try:
            p = Path(args.fmt[1])
            assert p.exists()
        except:
            raise Exception(
                "Please pass a valid path for a cdxml file - parsing failed"
            )
        pre = parse.get_mol_from_graph(args.fmt[1])
        collection, err = parse.prep_collection(pre)
        smiles_d = parse.get_smi_from_mols(collection)
    elif args.fmt[0] == "mol2":
        try:
            p = Path(args.fmt[1])
            assert p.exists()
        except:
            raise Exception(
                "Tried inputting a mol2, but did not specify a valid file path. Check input string."
            )
        mol = ml.Molecule.from_file(args.fmt[1])
        mol.name = p.stem.strip("/").strip(r"\\")  # strip slashes just in case
        assert isinstance(mol, ml.Molecule)
        pre = ml.Collection(name="mol2input", molecules=[mol])
        smiles_d = parse.get_smi_from_mols(pre)
        collection, err = parse.prep_collection(pre)
    else:
        raise Exception(
            "Please pass cdxml or smiles as input. See help for instructions."
        )

    ###             Building pipeline object for getting molecular geometries           ###

    collection.to_zip(parse.path_to_write + "input_struc_preopt_col.zip")
    import json

    assert not Path(
        STRUC_ + "newmol_smi_buffer.json"
    ).exists()  # Make sure we won't overwrite something
    with open(STRUC_ + "newmol_smi_buffer.json", "w") as k:
        json.dump(smiles_d, k)

    smi_list = [smiles_d[n.name] for n in collection.molecules]

    if args.fmt[0] == "smi":  # Single structure
        input_packet = PropheticInput.from_col(collection, smi_list, [args.r])
        # print(input_packet.struc)

    elif args.fmt[0] == "multismi":
        input_packet = PropheticInput.from_col(collection, smi_list, roles)
        # print(input_packet.struc)
    elif args.fmt[0] == "cdxml":
        input_packet = PropheticInput.from_col(
            collection, smi_list, [args.r for f in collection.molecules]
        )
        # print(input_packet.struc)
    elif args.fmt[0] == "mol2":  # Single structure
        input_packet = PropheticInput.from_col(collection, smi_list, [args.r])
    else:
        raise Exception(
            "There was an error attributing reactant roles for input structures"
        )
    ###                         Running conformer pipeline                               ###
    print("STARTING CONFORMER GENERATION AND SCREENING")
    input_packet.conformer_pipeline()
    print("STARTING ATOM PROPERTY CALCULATION")
    atomprops, ap_errors = input_packet.atomprop_pipeline()
    if len(ap_errors) > 0:
        warnings.warn(
            f"Looks like {len(ap_errors)} molecules failed at the atomproperty calculation step - this singlepoint calc usually fails because \
            the input structure is not valid. Check that backed up structure in the working directory {STRUC_} and check the output format in atomprop_pipelien"
        )
    ### Need to fix this - the atom properties buffer should really be written to the amines/bromides json.
    ### This is OK as a backup, but it should be added to a growing buffer on a molecule basis using the roles
    ### Should be a part of the PropheticInput class workflow.

    with open(STRUC_ + "newmol_ap_buffer.json", "w") as k:
        json.dump(atomprops, k)

    print(ap_errors)


if __name__ == "__main__":
    add_workflow()
